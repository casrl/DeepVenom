#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/mman.h>
#include <sys/types.h>
#include <sys/syscall.h>
#include <immintrin.h>
#include <x86intrin.h>
#include <dlfcn.h>

#include "prime_probe.h"

#define BUF_SIZE 1 * 1024 * 1024UL * 1024 // 1GB
uint64_t get_next_congrunet_line(void *buffer, int offset, int set_id, int slice_id);
uint64_t find_next_address_on_slice_and_set(void *va, uint8_t desired_slice, uint32_t desired_set);
uint64_t find_l1_eviction(void *buffer, int offset, int set_id);
uint64_t cache_set_canditate_finder(void *buffer, int offset, int set_id, int cache_level);


#define L1_PP_THRESH 35 // Set this

void **monitoring_set_all[L1_CACHE_SETS] = {NULL}; 

void **monitoring_set = NULL;
void **current = NULL, **previous = NULL;


uint64_t find_l1_eviction(void *buffer, int offset, int set_id) {
	bool found = false;

	while (!found) {
		offset = offset + CACHE_BLOCK_SIZE;
		if (get_cache_set_index((uint64_t)buffer + offset, 1) == set_id) {
			if ((get_cache_set_index((uint64_t)buffer + offset, 2) != set_id) && (get_cache_set_index((uint64_t)buffer + offset, 3) != set_id) ) {
				found = true;
			}
		}
	}

	return offset;
}

uint64_t cache_set_canditate_finder(void *buffer, int offset, int set_id, int cache_level) {
	bool found = false;
	int idx;
	while (!found) {
		offset += CACHE_BLOCK_SIZE;
		if (cache_level == 1) {
			idx = ((uint64_t)buffer+offset) & L1_SET_INDEX_MASK;
			idx = idx >> CACHE_BLOCK_SIZE_LOG;
		} else if (cache_level == 2) {
			idx = ((uint64_t)buffer+offset) & L2_SET_INDEX_MASK;
			idx = idx >> CACHE_BLOCK_SIZE_LOG;
		} else if (cache_level == 3) {
		}

		if (idx == set_id) found = true;
	}
	
	return  offset;;
}


void setup_evset() {
    int i, j, k;

	int eviction_set_size = L1_CACHE_WAYS;
	uint64_t eviction_set[eviction_set_size];

	int l1_eviction_set_size = L1_CACHE_WAYS * 2;
	uint64_t l1_set[l1_eviction_set_size];
	uint64_t l1_eviction_set[l1_eviction_set_size/2];
	uint64_t l1_monitoring_set[l1_eviction_set_size/2];

	bool staisfied = true;
	bool l1_found = false;

	uint64_t prev,curr, l1_idx;
	int to_found = 0;

	void *buffer = mmap(NULL, BUF_SIZE, PROT_READ | PROT_WRITE, MAP_ANON | MAP_PRIVATE | MAP_HUGETLB, -1, 0);
	if (buffer == MAP_FAILED) {
		perror("mmap");
		exit(1);
	}
	memset(buffer, 0, BUF_SIZE); // Prevent page fault for pace allocation

    // Loop through all cache sets (0 to 63)
    for (int set_id = 0; set_id < L1_CACHE_SETS; set_id++) {
    	unsigned long long monitoring_set_size = (unsigned long long)L1_CACHE_WAYS+1;
    	uint64_t index1, index2, offset;
        // Find first address in the given cache set
        offset = cache_set_canditate_finder(buffer, 0, set_id, 1);
        
        // Save this address in the monitoring set for the current set_id
        monitoring_set_all[set_id] = (void **)((uint64_t)buffer + offset);

        // Get the L1 cache set indexes of the monitoring set
        index1 = get_cache_set_index((uint64_t)monitoring_set_all[set_id], 1);
        assert(index1 == set_id);  // Ensure the address is within the desired cache set

        // Find next addresses that reside in the same L1/L2 sets
        current = monitoring_set_all[set_id];
        for (int i = 1; i < monitoring_set_size; i++) {
            // Adjust the offset until the address falls in the same set (L1 and L2)
            while ((index1 != get_cache_set_index((uint64_t)current + offset, 1)) || 
                   (index1 != get_cache_set_index((uint64_t)current + offset, 2))) {
                offset += CACHE_BLOCK_SIZE;  // Move to the next cache block
            }

            // Set up pointer chasing: *current = next address
            *current = (void **)((uint64_t)current + offset);
            current = (void**) *current;
        }
    }

}


bool probe_one(int set_id) {
	current = monitoring_set_all[set_id];
    uint64_t start = 0, end = 0;
    start = rdtsc3();
	for (int i = 0; i < L1_CACHE_WAYS; i++) {

		// Access the addresses sequentially.
		// Pointer chasing ensures that they are serialized.
		// By the time we reach each address, it probably won't be in the L1 and L2 anymore.
		// So this should give the LLC access time, without the need for an eviction set.
		asm volatile(
			".align 32\n\t"
			"lfence\n\t"
			"movl %%eax, %%r8d\n\t" /* r8d = eax */
			"movq (%1), %1\n\t"		/* current = *current; LOAD */
			: "+rm"(current)
			:
			: "rax", "rcx", "rdx", "r8", "memory");
	}
    end = rdtsc3();
    if ((end - start) > L1_PP_THRESH) {
        return true;
    }
    return false;
}

int probe_all() {
    while (1) {
        for (int i = 0; i < L1_CACHE_SETS; i++) {
            if(probe_one(i)) {
                return i;
            }
        }
    }
}



//   int samples = 100000;

//   l1pp_t l1 = l1_prepare(NULL);

//   int nsets = l1_getmonitoredset(l1, NULL, 0);

//   int *map = calloc(nsets, sizeof(int));
//   l1_getmonitoredset(l1, map, nsets);

//   int rmap[L1_SETS];
//   for (int i = 0; i < L1_SETS; i++)
//     rmap[i] = -1;
//   for (int i = 0; i < nsets; i++)
//     rmap[map[i]] = i;
  

//   uint16_t *res = calloc(samples * nsets, sizeof(uint16_t));
//   for (int i = 0; i < samples * nsets; i+= 4096/sizeof(uint16_t))
//     res[i] = 1;

//   l1_repeatedprobe(l1, samples, res, 0);

//   for (int i = 0; i < samples; i++) {
//     for (int j = 0; j < L1_SETS; j++) {
//       if (rmap[j] == -1) {}
//       else
//       {
//         if (res[i*nsets + rmap[j]] > THRESHOLD) {
//           printf("Starting offset: %d\n", j*64);
//         }
//       }
//     }
//   }