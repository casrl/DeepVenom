#ifndef PP_UTIL
#define PP_UTIL


#include <cstdint>
#include <errno.h>
#include <fcntl.h>
#include <inttypes.h>
#include <stdio.h>
#include <unistd.h>
#include <x86intrin.h>
#include <sys/mman.h>
#include <sys/resource.h>
#include <cstring>
#include <iostream>
#include <fstream>
#include <vector>
#include <assert.h> 
#include <stdlib.h> 
#include <bits/stdc++.h>
#include <time.h>


// x86 defaults
#define PAGE_SHIFT 12
#define PAGEMAP_LENGTH 8
#define PAGE 4096


// Courtesy of Lord of the rings (USENIX Security'21)
// These numbers are specifically for Skylake i7-6700/K
#define CACHE_BLOCK_SIZE 64
#define CACHE_BLOCK_SIZE_LOG 6

#define L1_CACHE_WAYS 8
#define L1_CACHE_SETS 64
#define L1_CACHE_SETS_LOG 6
#define L1_CACHE_SIZE (L1_CACHE_SETS) * (L1_CACHE_WAYS) * (CACHE_BLOCK_SIZE)

#define L2_CACHE_WAYS 4
#define L2_CACHE_SETS 1024
#define L2_CACHE_SETS_LOG 10
#define L2_CACHE_SIZE (L2_CACHE_SETS) * (L2_CACHE_WAYS) * (CACHE_BLOCK_SIZE)

#define LLC_CACHE_WAYS 16
#define LLC_CACHE_SETS_TOTAL 8192
#define LLC_CACHE_SETS_PER_SLICE 2048
#define LLC_CACHE_SETS_LOG 11
#define LLC_CACHE_SLICES 4
#define LLC_CACHE_SIZE (LLC_CACHE_SETS_TOTAL) * (LLC_CACHE_WAYS) * (CACHE_BLOCK_SIZE)

/* 
 * Set indexes 
 */

#define L1_SET_INDEX_MASK 0xFC0				 /* 6 bits - [11-6] - 64 sets + 8 way for each core */
#define L2_SET_INDEX_MASK 0xFFC0			 /* 10 bits - [15-6] - 1024 sets + 4 way for each core  */
#define LLC_SET_INDEX_PER_SLICE_MASK 0x1FFC0 /* 11 bits - [16-6] - 2048 sets + 16 way for each slice  */
#define LLC_INDEX_STRIDE 0x20000			 /* Offset required to get the next address with the same LLC cache set index. 17 = bit 16 (MSB bit of LLC_SET_INDEX_PER_SLICE_MASK) + 1 */
#define L2_INDEX_STRIDE 0x10000				 /* Offset required to get the next address with the same L2 cache set index. 16 = bit 15 (MSB bit of L2_SET_INDEX_MASK) + 1 */

/* 
 * Get the page frame number
 */
static uint64_t get_page_frame_number_of_address(void *address)
{
	/* Open the pagemap file for the current process */
	FILE *pagemap = fopen("/proc/self/pagemap", "rb");

	/* Seek to the page that the buffer is on */
	uint64_t offset = (uint64_t)((uint64_t)address >> PAGE_SHIFT) * (uint64_t)PAGEMAP_LENGTH;
	if (fseek(pagemap, (uint64_t)offset, SEEK_SET) != 0) {
		fprintf(stderr, "Failed to seek pagemap to proper location\n");
		exit(1);
	}

	/* The page frame number is in bits 0-54 so read the first 7 bytes and clear the 55th bit */
	uint64_t page_frame_number = 0;
	int ret = fread(&page_frame_number, 1, PAGEMAP_LENGTH - 1, pagemap);
	page_frame_number &= 0x7FFFFFFFFFFFFF; // Mastik uses 0x3FFFFFFFFFFFFF
	fclose(pagemap);
	return page_frame_number;
}

/*
 * Get the physical address of a page
 */
uint64_t get_physical_address(void *address)
{
	/* Get page frame number */
	unsigned int page_frame_number = get_page_frame_number_of_address(address);

	/* Find the difference from the buffer to the page boundary */
	uint64_t distance_from_page_boundary = (uint64_t)address % getpagesize();

	/* Determine how far to seek into memory to find the buffer */
	uint64_t physical_address = (uint64_t)((uint64_t)page_frame_number << PAGE_SHIFT) + (uint64_t)distance_from_page_boundary;

	return physical_address;
}


uint64_t rdtsc3() {
  /* Utility functions from https://github.com/IAIK/transientfail/ */
  uint64_t a, d;
  asm volatile("mfence");
  asm volatile("rdtscp" : "=a"(a), "=d"(d) :: "rcx");
  a = (d << 32) | a;
  asm volatile("mfence");
  return a;
}

uint64_t get_cache_set_index(uint64_t addr, int cache_level)
{
	uint64_t index;

	if (cache_level == 1) {
		index = (addr)&L1_SET_INDEX_MASK;

	} else if (cache_level == 2) {
		index = (addr)&L2_SET_INDEX_MASK;

	} else if (cache_level == 3) {
		index = (addr)&LLC_SET_INDEX_PER_SLICE_MASK;

	} else {
		exit(EXIT_FAILURE);
	}

	return index >> CACHE_BLOCK_SIZE_LOG;
}

#endif